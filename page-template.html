<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>1-2-2</title>

    <link rel="icon" type="image/x-icon" href="/a/resource/bg-image/highways/42.jpg">

    <link rel="stylesheet" href="/a/css/main.css">
    <link rel="stylesheet" href="/a/css/std-page.css">

    <script src="/a/script/data-fetch.js"></script>

    <style>
       
    </style>

    <noscript><style>
        body { background-image: url("/a/resource/bg-image/highways/29.jpg"); }
    </style></noscript>
</head>

<body>
    <script src="/a/script/random-bg.js"></script>

    <a href="/" id="home-button" style="color:black;">&#8634;</a>
    
    <div id="main-rect">

        <!-- multiple .body-rect divs may be used inside main-rect -->
    
        <div class="body-rect">

            <p style="text-align: center;">hello! how do you do</p>
            <p>pretty good</p>
            <p>**Filing in the year 2025**<br/>In the asdf, every file or directory is associated with exactly one parent directory. This creates an illusion of physicality, where we imagine that a storage volume is a big box, and all of our folders are smaller containers that sit neatly inside each other and hold our files. And that feels very natural <a href="">traditional file organization system</a> because it's how things have to work in the physical world &mdash; but it is an illusion. That kind of hierarchy doesn't really exist below a certain level &mdash; files on your hard drive live packed side by side wherever there's space for them. The filetree is more or less imaginary. It's a map. Its entries are not the files themselves, but mere references: metadata and an address to where on disk the data is actually stored. In many OSes, you can create "shortcuts" to files or directories which can be placed anywhere, but the idea remains firm that the original item is "real" and the shortcut is a "copy" &mdash; even though both are just references to the actual location of the file in question.<br/><br/>That said, there are some major advantages to this system. They are:<br/>- Ease of understanding &mdash; organization is intuitive because it models real-world objects<br/>- Ease of reference &mdash; every item has a single, concrete address in the filesystem<br/>- Human-readability &mdash; filepaths are legible and intuitive<br/><br/>The main disadvantage of the filetree as a tool is that it is totally, inflexibly linear. If what we have is a collection of discrete files and containers, then each file can only be in one container at a time. I've always found I spend far too much time on any given project fussing over exactly what directories and subdirectories to create to perfectly categorize all the project files in a meaningful and comprehensive way. You need to get this right at the beginning, because reorganizing your project later on can break references to file locations. The linear model is also conceptually limiting &mdash; in reality, things are often interrelated in ways that can't be expressed by discrete, nested folders. Not everything fits into exactly one category.<br/><br/>I'm suggesting a system here that preserves the advantages of the traditional filetree, and in fact would allow the user to navigate their files in the exact same way if they wished, but would also permit them to transcend the limitations of that structure and map data in a much more free and organic way. This would be achieved through what I'd call a transparent filemap &mdash; one that more honestly represents the relationship between the data on disk and the organizational structure that allows the user to access it. It would accomplish this essentially by conceptualizing all files and directories as pointers/references to data rather than the actual embodiment of the data itself, and by only implementing features that flow from this principle.<br/><br/>I'm taking a detour here to talk about tag-based organization. A lot of people are crazy about it. A friend of mine recommended I try Eagle, which is a program that lets you add metadata labels to files on your computer and then filter them by those labels. Youtube frequently serves me videos extolling the incredible, mind-expanding intuitiveness of Obsidian's organizational system, which lets you add tags to text documents as well as hyperlinks to other documents. I found Eagle largely useless, and while I am a dedicated Obsidian user, I quickly gave up on these features in favor of regular old folders. Proponents of these systems will tell you about how they let you organize files non-hierarchically, as an organic network of associations rather than a rigid structure. Instead of fitting strictly into one category, a given item can be connected to several different categories by adding multiple tags. To me, though, the whole thing just feels too messy. Like all my files are just floating around in this big soup, and I have to apply the right tags to skim out the ones that I want to see. Because there isn't a firm organizational structure for the tags themselves, there's no sense that anything is solid or really exists in any particular place. I'd like to incorporate the freedoms afforded by this kind of system while still maintaining a sense of structure and solidity.<br/><br/>**My ideal filesystem**<br/>The central idea here is transparency. The filemap is a way of organizing references to data locations on disk. It's kind of like a phonebook. How the system I'm suggesting differs from the traditional filetree is that, unlike the traditional filetree, it doesn't encourage you to believe that the people listed actually live *in* the phonebook. The filemap is not a container filled with objects; it's a structured list of addresses. In practice, this means two things are now permitted:<br/>- Duplicate references: multiple identical items can exist in the filemap that reference the same data on disk. You can have two instances of "abc.txt" in two different directories, and when you edit one, the changes are reflected in both, because they're the same object. The same is true of directories; one directory can be linked to inside of multiple other directories. None of them is the "real" one; they are all equally illusory.<br/>- Recursive directories: because multiple instances of the same directory can exist, it is possible to place a link to directory B inside directory A, then another link to directory A inside directory B. This does not necessarily cause any issues because B is not actually "inside" A; A only contains a link/reference to B.<br/><br/>A quick note on terminology:<br/>- "Filehead": This is what I'm calling a reference in the filemap to a specific file. A filehead is anything that appears in your file browser and has a name like "xyz.jpg". It consists only of a name, an association with a file on disk (via a unique ID), and some amount of metadata. I want to disambiguate the ideas of "file" and "filehead" because calling it a "file" reinforces the fiction that the data is physically present inside the directories it appears in. (If this system were implemented people would certainly just go on calling these "files", which is fine! But I want to be as clear as possible here.)<br/>- "Directory": While functionally similar, I want to distinguish this conceptually from directories/folders in the traditional filetree. A directory here should be thought of less as a container and more as a list of addresses/links &mdash; sort of like a webpage. (I may make casual reference to things being "inside" a directory. It's fine; it's a useful shorthand; it's just not strictly what's happening.) Every directory consists of a name, a unique ID, associations with one or more parent directories and zero or more subordinate directories/fileheads, and some metadata.</p>

        </div>

        <div class="body-rect">
                
            <p>*Names, IDs, Addresses:*<br/>In this system it is necessary for every file and directory to have a unique ID, separate from its name. This is because a filehead's location in the filemap is not treated as a defining aspect of the file itself. So, in a sense, all files are sharing a namespace. It would be ridiculous to require a unique name for every file, and so IDs are needed. It's also necessary because a file may have multiple fileheads and it needs to be clear that they actually reference the same file rather than just having the same name.<br/><br/>File addresses are still functional and coherent, but are not necessarily one-to-one with files. There may be multiple valid paths that reference the same file, because it may have multiple fileheads in different locations, or be attached to a directory that has duplicates in various places. This should not cause any problems as long as the address describes some valid path to the file.<br/><br/>Files may be referenced either by their ID or by a valid filepath that points to them. References by ID are more stable because they will remain valid irrespective of any reorganization of the filemap. References by address are more prone to being invalidated by moving things around, but are much more human-readable. References can also be a hybrid of the two, i.e., a relative address starting from a directory ID.<br/><br/>*Structure:*<br/>At a base level, the filemap would look pretty similar to a typical filetree. There's a root directory that everything else is attached to. That would list other directories, which would list other directories and fileheads and so on. The system would be very intuitive for anyone used to the traditional filetree &mdash; use of recursive organization and duplicate references is totally optional. Without using these features, the system behaves essentially identically to the filetree. However, for those who choose to use them, they've got a lot of potential.</p>

        </div>

    </div>

</body>

</html>