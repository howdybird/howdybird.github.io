<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>1-2-2</title>

    <link rel="icon" type="image/x-icon" href="/a/resource/bg-image/highways/42.jpg">

    <link rel="stylesheet" href="/a/css/main.css">
    <link rel="stylesheet" href="/a/css/std-page.css">

    <script src="/a/script/data-fetch.js"></script>

    <style>
       
    </style>

    <noscript><style>
        body { background-image: url("/a/resource/bg-image/highways/29.jpg"); }
    </style></noscript>
</head>

<body>
    <script src="/a/script/random-bg.js"></script>

    <a href="/" id="home-button">&#8634;</a>
    
    <div id="main-rect">

        <!-- multiple .body-rect divs may be used inside main-rect -->
    
        <div class="body-rect">

            <h2>
                honest filing
            </h2>
            <h3>
                a dream about organization
            </h3>

            <p><a href="https://youtu.be/woq5bSLQq18">This video</a> has me thinking about non-hierarchical filing systems. The video, and the series it's a part of, point out a lot of issues with the current UX/file-org paradigm that I totally agree with (and will rehash many of here), but in my opinion doesn't quite manage to articulate a vision for an alternative system that would still be practical/functional. In fact, I've never seen a system implemented or described that could satisfy everything I want re: file organization (although I'm sure someone out there has done so). This is my attempt to lay out a vision for an ideal digital filing system that would eliminate what I consider to be the key weaknesses of the traditional filetree while remaining intuitive, practical, and reliable.</p>
            <p><em>A note before we get into it: I am a total outsider to UX design, software design, basically anything related to the topic at hand.</em><em> I'm going to make up a lot of terms here for things that probably already have names.</em><em> My only qualifications are a lot of time spent on the computer and a passion for complaining.</em><br/> <br/> <strong>Filing now</strong><br/> In the traditional file organization system, every file or directory is associated with exactly one parent directory. This creates an illusion of physicality, where we imagine that a storage volume is a big box, and all of our folders are smaller containers that sit neatly inside each other and hold our files. And that feels very natural because it's how things have to work in the physical world &mdash; but it is an illusion. That kind of hierarchy doesn't really exist below a certain level &mdash; files on your hard drive live packed side by side wherever there's space for them. The filetree is more or less imaginary. It's a map. Its entries are not the files themselves, but mere references: metadata and an address to where on disk the data is actually stored. In many OSes, you can create "shortcuts" to files or directories which can be placed anywhere, but the idea remains firm that the original item is "real" and the shortcut is a "copy" &mdash; even though both are just references to the actual location of the file in question.<br/> <br/> That said, there are some major advantages to this system. They are:<br/> - Ease of understanding &mdash; organization is intuitive because it models real-world objects<br/> - Ease of reference &mdash; every item has a single, concrete address in the filesystem<br/> - Human-readability &mdash; filepaths are legible and intuitive<br/> <br/> The main disadvantage of the filetree as a tool is that it is totally, inflexibly linear. If what we have is a collection of discrete files and containers, then each file can only be in one container at a time. I've always found I spend far too much time on any given project fussing over exactly what directories and subdirectories to create to perfectly categorize all the project files in a meaningful and comprehensive way. You need to get this right at the beginning, because reorganizing your project later on can break references to file locations. The linear model is also conceptually limiting &mdash; in reality, things are often interrelated in ways that can't be expressed by discrete, nested folders. Not everything fits into exactly one category.<br/> <br/> I'm suggesting a system here that preserves the advantages of the traditional filetree, and in fact would allow the user to navigate their files in the exact same way if they wished, but would also permit them to transcend the limitations of that structure and map data in a much more free and organic way. This would be achieved through what I'd call a transparent filemap &mdash; one that more honestly represents the relationship between the data on disk and the organizational structure that allows the user to access it. It would accomplish this essentially by conceptualizing all files and directories as pointers/references to data rather than the actual embodiment of the data itself, and by only implementing features that flow from this principle.<br/> <br/> I'm taking a detour here to talk about tag-based organization. A lot of people are crazy about it. A friend of mine recommended I try Eagle, which is a program that lets you add metadata labels to files on your computer and then filter them by those labels. Youtube frequently serves me videos extolling the incredible, mind-expanding intuitiveness of Obsidian's organizational system, which lets you add tags to text documents as well as hyperlinks to other documents. I found Eagle largely useless, and while I am a dedicated Obsidian user, I quickly gave up on these features in favor of regular old folders. Proponents of these systems will tell you about how they let you organize files non-hierarchically, as an organic network of associations rather than a rigid structure. Instead of fitting strictly into one category, a given item can be connected to several different categories by adding multiple tags. To me, though, the whole thing just feels too messy. Like all my files are just floating around in this big soup, and I have to apply the right tags to skim out the ones that I want to see. Because there isn't a firm organizational structure for the tags themselves, there's no sense that anything is solid or really exists in any particular place. I'd like to incorporate the freedoms afforded by this kind of system while still maintaining a sense of structure and solidity.<br/> <br/> <strong>The dream</strong><br/> The central idea here is transparency. The filemap is a way of organizing references to data locations on disk. It's kind of like a phonebook. How the system I'm suggesting differs from the traditional filetree is that, unlike the traditional filetree, it doesn't encourage you to believe that the people listed actually live *in* the phonebook. The filemap is not a container filled with objects; it's a structured list of addresses. In practice, this means two things are now permitted:<br/> - Duplicate references: multiple identical items can exist in the filemap that reference the same data on disk. You can have two instances of "abc.txt" in two different directories, and when you edit one, the changes are reflected in both, because they're the same object. The same is true of directories; one directory can be linked to inside of multiple other directories. None of them is the "real" one; they are all equally illusory.<br/> - Recursive directories: because multiple instances of the same directory can exist, it is possible to place a link to directory B inside directory A, then another link to directory A inside directory B. This does not necessarily cause any issues because B is not actually "inside" A; A only contains a link/reference to B.<br/> <br/> A quick note on terminology:<br/> - "Filehead": This is what I'm calling a reference in the filemap to a specific file. A filehead is anything that appears in your file browser and has a name like "xyz.jpg". It consists only of a name, an association with a file on disk (via a unique ID), and some amount of metadata. I want to disambiguate the ideas of "file" and "filehead" because calling it a "file" reinforces the fiction that the data is physically present inside the directories it appears in. (If this system were implemented people would certainly just go on calling these "files", which is fine! But I want to be as clear as possible here.)<br/> - "Directory": While functionally similar, I want to distinguish this conceptually from directories/folders in the traditional filetree. A directory here should be thought of less as a container and more as a list of addresses/links &mdash; sort of like a webpage. (I may make casual reference to things being "inside" a directory. It's fine; it's a useful shorthand; it's just not strictly what's happening.) Every directory consists of a name, a unique ID, associations with one or more parent directories and zero or more subordinate directories/fileheads, and some metadata.<br/> <br/> <em>Names, IDs, </em><em>a</em><em>ddresses:</em><br/> In this system it is necessary for every file and directory to have a unique ID, separate from its name. This is because a filehead's location in the filemap is not treated as a defining aspect of the file itself. So, in a sense, all files are sharing a namespace. It would be ridiculous to require a unique name for every file, and so IDs are needed. It's also necessary because a file may have multiple fileheads and it needs to be clear that they actually reference the same file rather than just having the same name.<br/> <br/> File addresses are still functional and coherent, but are not necessarily one-to-one with files. There may be multiple valid paths that reference the same file, because it may have multiple fileheads in different locations, or be attached to a directory that has duplicates in various places. This should not cause any problems as long as the address describes some valid path to the file.<br/> <br/> Files may be referenced either by their ID or by a valid filepath that points to them. References by ID are more stable because they will remain valid irrespective of any reorganization of the filemap. References by address are more prone to being invalidated by moving things around, but are much more human-readable. References can also be a hybrid of the two, i.e., a relative address starting from a directory ID.<br/> <br/> <em>Structure:</em><br/> At a base level, the filemap would look pretty similar to a typical filetree. There's a root directory that everything else is attached to. That would list other directories, which would list other directories and fileheads and so on. The system would be very intuitive for anyone used to the traditional filetree &mdash; use of recursive organization and duplicate references is totally optional. Without using these features, the system behaves essentially identically to the filetree. However, for those who choose to use them, they've got a lot of potential.<br/> <br/> Say I'm organizing my photo folder. I've got my main "photos" directory that lists all of my photos. Inside that, I would make a "categories" directory, and inside that I might have directories like "vacation 2021", "family", et cetera. I would then create duplicate references to all of my family photos in the "family" directory. That way they're visible both in "photos" and "family". It would also be possible to select a file and see the locations of all the fileheads that reference it. It would be easy to implement slightly more complex search functions, such as selecting two (or more) directories and finding all the items that are present in both. This would provide all the functionality of a tagging system, pretty smoothly, while avoiding the pitfalls.<br/> <br/> Recursion is also allowed. For instance, I might create something like a "bookmarks" directory, for quick access to other useful directories, and if I wanted to I could place an instance of my root directory inside it. Again, while this may seem intuitively wrong, it works because neither directory really contains the other one; both are just a list of addresses.<br/> <br/> The root directory itself doesn't quite hold the same stature as it does in a traditional filesystem. Its function is that it is the only object in the filemap that can exist without being referenced in another directory. Thus it acts as an anchor or starting point that allows users and programs to navigate elsewhere in the filemap.<br/> <br/> <em>Duplicates, </em><em>d</em><em>eletion, </em><em>d</em><em>ereferencing</em><br/> All fileheads referencing the same file are completely identical; their name and all other metadata is the same, as these represent aspects of the file itself. The filehead should be understood as a totally null, formless object that reflects the qualities of the file it references and anchors it to a specific location in the filemap.<br/> <br/> With this reference-based model, there are now two forms of duplication and two forms of deletion. If I'm looking at a filehead in my file browser, there are two ways I can duplicate it: I can make a "soft copy", which creates a new filehead referencing the same file. Opening either the original filehead or the copy will open the same exact file. Making a soft copy does not take up any extra storage space (or rather, only a negligible amount). Or, I can make a "hard copy", which actually duplicates the file itself. This is what I would do if I wanted a version of the file I could edit without affecting the original. Likewise with deletion: I can either delete the filehead, which removes it from whatever directory it's in but doesn't affect the file itself ("soft delete"); or I can delete the file itself, which also deletes all fileheads that reference it ("hard delete"). In implementation, these could be assigned to different keystrokes, e.g. delete vs. backspace or delete vs. ctrl+delete.<br/> <br/> As I said, the filehead acts as an anchor, connecting the file to a specific location in the filemap. If all of the fileheads referencing a file are deleted, there will be no convenient way to access it from the filesystem. It would be counterproductive to allow files to exist in this state, so when a file is dereferenced, it is deleted, or at least scheduled for deletion. There could be another independent directory (similar to the root directory; can exist without being referenced) that serves as a trash bin &mdash; when the last reference to a file is deleted, a new filehead is created there; then, after some period of time, the filehead and the file are routinely deleted.<br/> <br/> A directory will also be fully deleted if the last instance of it is deleted (or if a "hard delete" is performed on any instance). If any items in the directory are the only existing instance of themselves, the user should be given a warning, as they will be hard deleted. It might also be good to give the user the option to relocate the references elsewhere. Perhaps several optional, more nuanced recursive delete commands would be helpful.<br/> <br/> <em>Smart </em><em>d</em><em>irectories:</em><br/> There's probably a better name for this, since "smart" technology has some insidious connotations. Anyway, this isn't a "core" feature of the system, but it is something I daydream about often.<br/> <br/> It goes like this: I create a "smart directory" somewhere in the filesystem. I choose one or more source directories that it will source its contents from. I choose whether it will index recursively, and if so how many directories deep it should go. I choose what filters it will apply to those files: name, date created, or any other metadata. The smart directory will then automatically populate with all files that fit the criteria. Because duplicate references are allowed, this would not affect the files or any other references to them. It would merely be a useful organizational tool. A few examples:<br/> - A "recent files" directory that sources from the root directory and filters the most recently opened files (Perhaps this could be included by default)<br/> - A directory that lists all your photos from a specific period of time<br/> - Directories that separate project files by type (e.g. a videos folder, a text documents folder, etc.)<br/> If this model were implemented on a small scale, such as in a program that mostly handles text files, perhaps filters could be applied that pertain to content as well as metadata.<br/> <br/> Because smart directories are automatically managed and source their contents from other directories, the fileheads they contain should be considered "weak" references, meaning that they cannot be the only reference to a file.<br/> <br/> <strong>Implementation, </strong><strong>a</strong><strong>pplications</strong><br/> My dream, of course, would be to have an entire operating system working with a transparent filemap like this. Just think of the ways it would make life easier:<br/> - Simplified and more intuitive shortcuts &mdash; for example, app icons on your desktop/taskbar/etc. would be fileheads associated with executable files, which could then contain a reference by ID to a directory of relevant program files.<br/> - Improved integration of programs with native filesystem &mdash; programs such as video editors (and many others I'm sure, but my experience is with video) often have you "import" files, then have their own internal file manager to organize them. However, this superficial filesystem is only accessible inside the program, and doesn't affect the actual organization of the files in the OS' filesystem &mdash; and now if you move the files to a different location in the external filesystem, the reference is broken and the program can't find your files. Some programs import files by actually copying them, which is more stable but also uses up more storage space and is impractical if you're working with large files. This new filemap solves both problems &mdash; programs could create project directories with references to files that would be stable and secure without taking up extra space.<br/> - Near-total organizational freedom &mdash; this system is not inherently hierarchal, but you can impose whatever level of hierarchy is useful for whatever you're trying to accomplish. It more or less gives you complete freedom to organize things in whatever shape suits you.<br/> <br/> But hell, I don't know how to build it! And anyhow, I don't know how useful it would be given the current OS landscape. Perhaps it would be possible to construct some kind of Linux system that would function somewhat like this? Or a file manager that would emulate it? Even if that's possible, adopting a system like this would probably make it very impractical for the computer using it to interface and transfer files with other computers. So, for now, I think the transparent OS is likely to remain a fantasy.<br/> <br/> However, I could see a model like this being very useful in the context of a more self-contained software implementation. For instance, an Obsidian-esque text editor or an email client that organizes files this way could be incredibly helpful. But! the way it would probably have to work is by keeping all the files in its scope in a single directory in the external filesystem, then organizing them in a virtual filesystem internally (similar to the video-editor model I talked about a second ago). And I don't love that, because it adds a level of abstraction to how the program operates &mdash; it's important to me that a user be able to access and navigate their files outside of whatever specific program they're using.<br/> <br/> But wouldn't it be neat!</p>
            
        </div>

    </div>

</body>

</html>